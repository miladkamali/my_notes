// Copyright (c) 2020, Saman Solutions Co.
//
// Unauthorized copying of this file, via any medium is strictly prohibited.
// Proprietary and confidential, All Rights Reserved.
//
// Written by Amir-Abbas Mousavian <mosavian@mobillet.ir>.

syntax = "proto3";

package solutions.saman.base;

option cc_enable_arenas = true;
option java_multiple_files = true;

option java_package = "uid.backend.kyc";
option swift_prefix = "";

import "google/protobuf/timestamp.proto";

import "validate/validate.proto";

/*
 * A structure to contain ASN.1 encoded byte stream of salted and encrypted password or PIN data.
 *
 * - Important: Device-specified public keys must exchanged before login via `SessionKeyExchange` service.
 *
 * - Important: Salt is the as secret key generated via DH/ECDH method during key exchange process.
 */
message Password {
  /*
   * **REQUIRED** Byte array of salted and encrypted password/PIN.
   */
  bytes encoded = 1 [(validate.rules).bytes.min_len = 1];
}

// Standardized encryption/decryption methods for values in `Password` message.
enum CipherMethod {
  // No cipher algorithm is specified by client. Server must not tolerate this value.
  CIPHER_METHOD_UNSPECIFIED = 0;

  /*
   * Cipher algorithm to encrypt:
   *   - Create AES key using SHA2/256 hash function on shared secret.
   *   - Do AES-256 cipher on data using derived symmetric key in previous step.
   *   - Send the combined representation (nonce || ciphertext || tag) in `encoded` field.
   *
   * ```kotlin
   *
   * ```
   *
   * ```swift
   * import CryptoKit
   * let sharedSecretData = sharedSecret.withUnsafeBytes({ Data(buffer: $0.bindMemory(to: UInt8.self)) })
   * let keyData = SHA256.hash(data: secData)
   * let symmetricKey = SymmetricKey(data: sha)
   * let encoded = try AES.GCM.seal(Data(plainText.utf8), using: symmetricKey)
   * password.encoded = encoded.combined!
   * ```
   */
  CIPHER_METHOD_SHA256_AES256_GCM_V1 = 1;

  /*
   * Cipher algorithm:
   *   - Create AES key using truncating first 32 bytes of shared secret.
   *   - Do AES-256 cipher on data using derived symmetric key in previous step.
   *   - Send the combined representation ( nonce || ciphertext || tag) in `encoded` field.
   *
   * ```swift
   * import CryptoKit
   * let sharedSecretData = sharedSecret.withUnsafeBytes({ Data(buffer: $0.bindMemory(to: UInt8.self)) })
   * let keyData = secData.prefix(32)
   * let symmetricKey = SymmetricKey(data: sha)
   * let encoded = try AES.GCM.seal(Data(plainText.utf8), using: symmetricKey)
   * password.encoded = encoded.combined!
   * ```
   */
  CIPHER_METHOD_AES256_GCM_V1 = 3;
}

// Plain (username/password based) authentication request information.
message AuthenticationPlain {
  // **REQUIRED** Username.
  string username = 1 [(validate.rules).string.pattern = "^(?!(.*@.*@.*))(?!(.+[_@\\-\\.]{2,}.+))(?!^(0|\\+98|0098)[1-9]\\d{9}$)[A-Za-z0-9][A-Za-z0-9_@\\-\\.]{1,18}[A-Za-z0-9]$"];

  // **REQUIRED** Encrypted password.
  Password password = 2 [(validate.rules).message.required = true];
}

/*
 * A structure contains the id of challenge retrieved form server and sign of the contents.
 */
message SignedChallenge {
  // **REQUIRED** message of challenge to be signed, generated by server.
  bytes message = 1 [(validate.rules).bytes.min_len = 16];

  // **REQUIRED** The signature to verify, generated using ECDSA using private key pair of `device_public_key`.
  bytes signature = 2 [(validate.rules).bytes.min_len = 1];
}

// Reason of anonymous login, which helps server to return appropriate navigation url.
enum AuthenticationAnonymousReason {
  // Client does not determine a reason and server won't return navigation uri.
  AUTHENTICATION_ANONYMOUS_REASON_UNSPECIFIED = 0;

  // Client intends to start sign up account process.
  AUTHENTICATION_ANONYMOUS_REASON_SIGN_UP_ACCOUNT = 2;

  // Client intends to recover username or password.
  AUTHENTICATION_ANONYMOUS_REASON_RECOVERY_CREDENTIAL = 3 [deprecated = true];

  // Client intends to open support chat.
  AUTHENTICATION_ANONYMOUS_REASON_CUSTOMER_SUPPORT = 4;

  // Client intends to recover username.
  AUTHENTICATION_ANONYMOUS_REASON_RECOVERY_USERNAME = 5;

  // Client intends to recover password.
  AUTHENTICATION_ANONYMOUS_REASON_RECOVERY_PASSWORD = 6;
}

// Authentication for KYC process.
message AuthenticationAnonymous {
  // Reason of anonymous login, which helps server to return appropriate navigation url.
  AuthenticationAnonymousReason reason = 1 [(validate.rules).enum = {not_in: [0]}];
}

// Authentication for other related domains.
message AuthenticationSSOToken {
  // Domain name.
  //
  // For blu Junior, use: "junior.blubank.com".
  string domain = 1 [(validate.rules).string.hostname = true];
}

// Authenticate user using one of available methods
message Authentication {
  /*
   * **REQUIRED** Device-associated P-256 (secp256r1) public key in ASN.1 representation.
   *
   * - Important: Device must store private key in safest possible place, e.g. in Secure Enclave on iPhones. and limit access via biometric authentication if possible.
   *
   * - Important: Server must store this key associated with `device.id` permanently.
   */
  bytes device_public_key = 1 [(validate.rules).bytes.min_len = 1];

  // **REQUIRED** Authentication method.
  oneof oneof_authentication {
    option (validate.required) = true;

    // Anonymous session
    AuthenticationAnonymous anonymous = 2;

    // Plain (username/password based) authentication request information.
    AuthenticationPlain plain = 3;

    // Authenticating using predefined device id and public key.
    SignedChallenge signed_challenge = 4;

    // Authentication for other related domains.
    AuthenticationSSOToken sso_domain = 21;
  }
}

// Authentication token returned by server during login.
message AuthenticationToken {
  /*
   * Determines when the token is created.
   *
   * - Important: Client MUST reject token if current system date is less than given issue date with tolerance of 30 seconds.
   *
   * - Important: Client MUST reject token if current system date is greater than given issue date with tolerance of 60 seconds.
   */
  google.protobuf.Timestamp issue_date = 1;

  /*
   * Determines when the token will be expired.
   *
   * - Important: Client MUST reject token if current system date is greater than given expiration date.
   */
  google.protobuf.Timestamp expire_date = 2;

  // **REQUIRED** Authentication method.
  oneof oneof_token {
    option (validate.required) = true;

    // Bearer token assigned by server during login.
    bytes bearer = 3;

    // Token to be used for SSO login.
    string sso_token = 21;
  }
}

// Type of the credentials being used.
enum CredentialType {
  // Other credential type, see element credentialSubType for additional detail.
  CREDENTIAL_TYPE_UNSPECIFIED = 0;

  // Username is a system ID that is typically a shortened version of their name with no spaces. It is used to access an account when the person is using a computer system. The user usually selects their user name during sign up. It is typically unique for that individual or account across the entire system of record.
  CREDENTIAL_TYPE_USERNAME = 1;

  // Password is a combination of characters known by the user that is used to access an account when the person is on a computer system.
  CREDENTIAL_TYPE_PASSWORD = 2;

  // Codeword is used to access an account in person or over the phone. This is typically different than the password used when electronically accessing the account.
  CREDENTIAL_TYPE_CODEWORD = 3;

  // The ATM PIN is usually a 4 digit number with no spaces that is used at an ATM terminal to access cash funds, inquire about balances or perform transfers. Depending upon the provider, this number can be randomly generated or selected by the user at time they create an account or activate their ATM card.
  CREDENTIAL_TYPE_ATM_PIN = 4;

  // A token that was generated by a system for accessing a system. Tokens can be rather lengthy to keep them confidential.
  CREDENTIAL_TYPE_TOKEN = 11;

  // Can be used to authorize transactions such as wire transfers, password reset, ACH transactions, etc.
  CREDENTIAL_TYPE_AUTHORIZATION_CODE = 12;

  // A question that the user has selected that is paired with a security answer, which the system uses to confirm that the person is authorized to the account. This is typically used in resetting the password on a system.
  CREDENTIAL_TYPE_SECURITY_QUESTION = 21;

  // An answer to a security question that the system uses to confirm that the person is authorized to the account. This is typically used in resetting the password on a system.
  CREDENTIAL_TYPE_SECURITY_ANSWER = 22;

  // A question that the user has selected and paired with a challenge answer so that the system can confirm that the person is authorized to the account. This is typically used to enable a higher risk transaction on an account that requires a higher level of authentication to perform the transaction, such as sending money externally.
  CREDENTIAL_TYPE_CHALLENGE_QUESTION = 31;

  // An answer to a challenge question that allows the system to confirm that the person is authorized to the account. This is typically used to enable a higher risk transaction on an account that requires a higher level of authentication to perform the transaction, such as sending money externally.
  CREDENTIAL_TYPE_CHALLENGE_ANSWER = 32;

  // A phrase that the user can assign so that when they log into their account, the user can confirm that they have not been sent to a different website. This prevents them from performing transactions or providing confidential information on a fraudulent site.
  CREDENTIAL_TYPE_ANTIPHISHING_PHRASE = 41;

  // A URL to an image that the user selected and assigned to their account so that when they log into their account, the user can confirm that they have not been sent to a different website. This prevents them from performing transactions or providing confidential information on a fraudulent site.
  CREDENTIAL_TYPE_ANTIPHISHING_IMAGE_URI = 42;

  // A pointer to an image in the artifact repository that the user selected and assigned to their account so that when they log into their account, the user can confirm that they have not been sent to a different website. This prevents them from performing transactions or providing confidential information on a fraudulent site.
  CREDENTIAL_TYPE_ANTIPHISHING_IMAGE_ARTIFACT_ID = 43;
}

// A structure that contains credential and its type.
message Credential {
  /*
   * **REQUIRED** Credential value in encrypted form.
   *
   * - Validation regex for plaintext username is `^[A-Z,a-z][A-Z,a-z,0-9]{4,}$`.
   * - Validation regex for plaintext password is `^(?=.*[a-z])(?=.*[A-Z])((?=.*[0-9]))[\x21-\x7e]{8,}$`.
   */
  Password value = 1 [(validate.rules).message.required = true];

  // Type of credential, e.g. password, atm pin or security answer
  CredentialType type = 2 [(validate.rules).enum = {not_in: [0]}];
}
