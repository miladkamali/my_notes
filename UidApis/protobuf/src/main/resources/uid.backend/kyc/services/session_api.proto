syntax = "proto3";

package uid.backend;

option cc_enable_arenas = true;
option java_multiple_files = true;
option java_package = "uid.backend.kyc.services";

import "validate/validate.proto";
import "google/api/annotations.proto";
import "uid.backend/kyc/base.proto";
import "uid.backend/kyc/auth.proto";

service SessionService {
  rpc KeyExchange(SessionKeyExchangeRequest) returns (SessionKeyExchangeResponse) {
    option (google.api.http) = {
      post: "/session/key-exchange"
      body: "*"
    };
  };
}


enum OTPType{
  OTP_TYPE_SMS = 0;
  OTP_TYPE_CALL = 1;
}

message OTPRequest{
  uid.backend.RequestContext context = 1;
  OTPType OTPType =2;
  string number = 3;
}

message OTPResponse{
  uid.backend.ResponseContext responseContext = 1;
}

message SessionKeyExchangeRequest {
  // **REQUIRED** Session and application associated data.
  uid.backend.RequestContext context = 1 [(validate.rules).message.required = true];

  /*
   * Device vendor identification.
   */
  bytes device_id = 2 [(validate.rules).bytes = {min_len: 8, max_len: 32}];

  /*
   * **REQUIRED** Ephemeral P-384 (secp384r1) public key generated by device encoded using ASN.1 in binary (DER) format.
   * This key will be be used for Diffie-Hellman key exchange (ECDH) on server and client.
   */
  bytes public_key = 3 [(validate.rules).bytes.len = 120];

  // Cipher algorithm for encrypting passwords.
  solutions.saman.base.CipherMethod cipher_method = 4 [(validate.rules).enum = {not_in: [0]}];
}

message SessionKeyExchangeResponse {
  backend.RequestContext context = 1 [(validate.rules).message.required = true];

  /*
   * P-384 (secp384r1) Ephemeral public key generated by server encoded using ASN.1 in binary (DER) format.
   * This key will be be used for Diffie-Hellman key exchange (ECDH) on server and client
   *
   * - Note: Client MUST store this key till session expires and must use this key to encrypt `Password`-type fields before sending on wire.
   */
  bytes public_key = 3;
}