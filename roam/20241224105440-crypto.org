:PROPERTIES:
:ID:       E5F46C83-F76A-4C4E-AF47-66BCE98A3EC8
:END:
#+title: crypto
* exchanges
** dydx
** toobit
* tools to get information
** https://playwright.dev/
** https://github.com/Kaliiiiiiiiii-Vinyzu/patchright-python
** https://app.octobot.cloud/intro/start
https://github.com/Drakkar-Software/OctoBot
* investment
** tools
*** [[hummingbot][https://hummingbot.org/strategies/]]
** investigate Hyperliquid Vault
* trading platform 
* videos
** [[https://www.youtube.com/watch?v=oDJ0XMqCl18][investigating bull runs in crypto]]
** 
* ideas
** integrating trading view with dydx
[[https://www.youtube.com/watch?v=I8hB2O2-xx4][integrate tradingview with dydx]]
https://github.com/junta/tradingview-alert-connector
https://tv-connector.gitbook.io/docs
https://www.dydxgrants.com/grants/tradingview-integration
* indicators
**  [[https://www.youtube.com/watch?v=4kgDKOfRZXw][7 POWERFUL Artificial Intelligence Indicators on TradingView ( SAVE THEM )]]
** [[https://www.youtube.com/watch?v=r0rcecNaams][The Best AI TradingView Indicator: Machine Learning SuperTrend !]]
https://www.algotradepro.com/free-content
** [[https://www.youtube.com/watch?v=9JEmsSItdt4][The Strategy That Made Him $1.1 Million In 12 Months]]
* sniping bots
[[https://www.youtube.com/watch?v=jGXJ4xxLIdc][How to Create Passive Income MEV Bot on Ethereum Full Tutorial]]
* research
** [[https://www.youtube.com/watch?v=oDJ0XMqCl18][How to Research the Crypto Market Using New AI-Powered Indicator | Step-by-Step Guide]]
https://pasteco.com/t9yc80yb
** [[https://www.youtube.com/watch?v=BgZg3eqJeVE][Improve TradingView Strategy with AI (add Indicator) (IT FINALLY WORKS)]]
*** 
You are a professional PineScript version=6 developer.
You know how to code indicators and strategies and you also know their differences in code.
I need your help to improve this TradingView strategy please.

Add this indicator to this strategy and remove the plots and fills it has:
[YOUR INDICATOR CODES GOES HERE]

Now improve the strategy like so:
- Open long position as soon as the gaussian channel is green, the close price is above the high gaussian channel band and when the Stochastic RSI is above 80 or below 20.
- Close long positions when the close price crosses the high gaussian channel band to the downside.

Respect these instructions:
- For the indicator we are adding, preserve the timeframe logic it has if there is one, fill gaps whenever possible.
- Keep all existing plots & visuals (don't remove them).
- Don't trigger a short. Simply go Long and Flat.
- Always use 100% of capital.
- Set commission to 0.1%.
- Set slippage to 3.
- strategy.commission.percent and strategy.slippage don't exist in PineScript. Please avoid this mistake. Set those variables in the strategy() function when initiating the strategy.
- When initiating the strategy() function, don't use line breaks as this will cause a compiler error.
- Leave all other strategy settings to default values (aka. don't set them at all).
- Never use lookahead_on because thatâ€™s cheating.
- Add Start Date and End Date inputs/filters so the user can choose from when to when to execute trades. Start with 1st January 2018 and go to 31st December 2069.
- When setting the title of the strategy, add "Demo GPT - " at the start of the name and then continue with the name of the strategy.

This is the code of the TradingView Strategy to improve with the instructions above:
[YOUR STRATEGY CODE GOES HERE]


***
//@version=5
strategy(title="Gaussian Channel Strategy v3.0", overlay=true, calc_on_every_tick=false, initial_capital=1000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, commission_type=strategy.commission.percent, commission_value=0.1, slippage=3, fill_orders_on_standard_ohlc=true)

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
// Gaussian Channel Indicator - courtesy of @DonovanWall
//----------------------------------------------------------------------------------------------------------------------------------------------------------------- 

// Date condition inputs
startDate = input.time(timestamp("1 January 2018 00:00 +0000"), "Start Date", group="Main Algo Settings")
endDate = input.time(timestamp("31 Dec 2069 23:59 +0000"), "End Date", group="Main Algo Settings")
timeCondition = time >= startDate and time <= endDate

// This study is an experiment utilizing the Ehlers Gaussian Filter technique combined with lag reduction techniques and true range to analyze trend activity.
// Gaussian filters, as Ehlers explains it, are simply exponential moving averages applied multiple times.
// First, beta and alpha are calculated based on the sampling period and number of poles specified. The maximum number of poles available in this script is 9.
// Next, the data being analyzed is given a truncation option for reduced lag, which can be enabled with "Reduced Lag Mode".
// Then the alpha and source values are used to calculate the filter and filtered true range of the dataset.
// Filtered true range with a specified multiplier is then added to and subtracted from the filter, generating a channel.
// Lastly, a one pole filter with a N pole alpha is averaged with the filter to generate a faster filter, which can be enabled with "Fast Response Mode". 

// Custom bar colors are included.

// Note: Both the sampling period and number of poles directly affect how much lag the indicator has, and how smooth the output is.
//      Larger inputs will result in smoother outputs with increased lag, and smaller inputs will have noisier outputs with reduced lag.
//      For the best results, I recommend not setting the sampling period any lower than the number of poles + 1. Going lower truncates the equation.

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
// Updates:
// Huge shoutout to @e2e4mfck for taking the time to improve the calculation method!
// -> migrated to v4
// -> pi is now calculated using trig identities rather than being explicitly defined.
// -> The filter calculations are now organized into functions rather than being individually defined.
// -> Revamped color scheme.

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
// Functions - courtesy of @e2e4mfck
//----------------------------------------------------------------------------------------------------------------------------------------------------------------- 

// Filter function 
f_filt9x (_a, _s, _i) => 
    int _m2 = 0, int _m3 = 0, int _m4 = 0, int _m5 = 0, int _m6 = 0, 
    int _m7 = 0, int _m8 = 0, int _m9 = 0, float _f = .0, _x = (1 - _a)
    // Weights. 
    // Initial weight _m1 is a pole number and equal to _i
    _m2 := _i == 9 ? 36  : _i == 8 ? 28 : _i == 7 ? 21 : _i == 6 ? 15 : _i == 5 ? 10 : _i == 4 ? 6 : _i == 3 ? 3 : _i == 2 ? 1 : 0
    _m3 := _i == 9 ? 84  : _i == 8 ? 56 : _i == 7 ? 35 : _i == 6 ? 20 : _i == 5 ? 10 : _i == 4 ? 4 : _i == 3 ? 1 : 0
    _m4 := _i == 9 ? 126 : _i == 8 ? 70 : _i == 7 ? 35 : _i == 6 ? 15 : _i == 5 ? 5  : _i == 4 ? 1 : 0
    _m5 := _i == 9 ? 126 : _i == 8 ? 56 : _i == 7 ? 21 : _i == 6 ? 6  : _i == 5 ? 1  : 0 
    _m6 := _i == 9 ? 84  : _i == 8 ? 28 : _i == 7 ? 7  : _i == 6 ? 1  : 0 
    _m7 := _i == 9 ? 36  : _i == 8 ? 8  : _i == 7 ? 1  : 0 
    _m8 := _i == 9 ? 9   : _i == 8 ? 1  : 0 
    _m9 := _i == 9 ? 1   : 0
    // filter
    _f :=   math.pow(_a, _i) * nz(_s) + 
      _i  *     _x      * nz(_f[1])      - (_i >= 2 ? 
      _m2 * math.pow(_x, 2)  * nz(_f[2]) : 0) + (_i >= 3 ? 
      _m3 * math.pow(_x, 3)  * nz(_f[3]) : 0) - (_i >= 4 ? 
      _m4 * math.pow(_x, 4)  * nz(_f[4]) : 0) + (_i >= 5 ? 
      _m5 * math.pow(_x, 5)  * nz(_f[5]) : 0) - (_i >= 6 ? 
      _m6 * math.pow(_x, 6)  * nz(_f[6]) : 0) + (_i >= 7 ? 
      _m7 * math.pow(_x, 7)  * nz(_f[7]) : 0) - (_i >= 8 ? 
      _m8 * math.pow(_x, 8)  * nz(_f[8]) : 0) + (_i == 9 ? 
      _m9 * math.pow(_x, 9)  * nz(_f[9]) : 0)

// 9 var declaration fun
f_pole (_a, _s, _i) =>
    _f1 =            f_filt9x(_a, _s, 1),      _f2 = (_i >= 2 ? f_filt9x(_a, _s, 2) : 0), _f3 = (_i >= 3 ? f_filt9x(_a, _s, 3) : 0)
    _f4 = (_i >= 4 ? f_filt9x(_a, _s, 4) : 0), _f5 = (_i >= 5 ? f_filt9x(_a, _s, 5) : 0), _f6 = (_i >= 6 ? f_filt9x(_a, _s, 6) : 0)
    _f7 = (_i >= 2 ? f_filt9x(_a, _s, 7) : 0), _f8 = (_i >= 8 ? f_filt9x(_a, _s, 8) : 0), _f9 = (_i == 9 ? f_filt9x(_a, _s, 9) : 0)
    _fn = _i == 1 ? _f1 : _i == 2 ? _f2 : _i == 3 ? _f3 :
      _i == 4     ? _f4 : _i == 5 ? _f5 : _i == 6 ? _f6 :
      _i == 7     ? _f7 : _i == 8 ? _f8 : _i == 9 ? _f9 : na
    [_fn, _f1]

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
// Inputs
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------

// Source
src = input(defval=hlc3, title="Source")

// Poles
int N = input.int(defval=4, title="Poles", minval=1, maxval=9)

// Period
int per = input.int(defval=144, title="Sampling Period", minval=2)

// True Range Multiplier
float mult = input.float(defval=1.414, title="Filtered True Range Multiplier", minval=0)

// Lag Reduction
bool modeLag  = input.bool(defval=false, title="Reduced Lag Mode")
bool modeFast = input.bool(defval=false, title="Fast Response Mode")

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
// Definitions
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------

// Beta and Alpha Components
beta  = (1 - math.cos(4*math.asin(1)/per)) / (math.pow(1.414, 2/N) - 1)
alpha = - beta + math.sqrt(math.pow(beta, 2) + 2*beta)

// Lag
lag = (per - 1)/(2*N)

// Data
srcdata = modeLag ? src + (src - src[lag]) : src
trdata  = modeLag ? ta.tr(true) + (ta.tr(true) - ta.tr(true)[lag]) : ta.tr(true)

// Filtered Values
[filtn, filt1]     = f_pole(alpha, srcdata, N)
[filtntr, filt1tr] = f_pole(alpha, trdata,  N)

// Lag Reduction
filt   = modeFast ? (filtn + filt1)/2 : filtn
filttr = modeFast ? (filtntr + filt1tr)/2 : filtntr

// Bands
hband = filt + filttr*mult
lband = filt - filttr*mult

// Colors
color1   = #0aff68
color2   = #00752d
color3   = #ff0a5a
color4   = #990032
fcolor   = filt > filt[1] ? #0aff68 : filt < filt[1] ? #ff0a5a : #cccccc
barcolor = (src > src[1]) and (src > filt) and (src < hband) ? #0aff68 : (src > src[1]) and (src >= hband) ? #0aff1b : (src <= src[1]) and (src > filt) ? #00752d : 
           (src < src[1]) and (src < filt) and (src > lband) ? #ff0a5a : (src < src[1]) and (src <= lband) ? #ff0a11 : (src >= src[1]) and (src < filt) ? #990032 : #cccccc

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
// Outputs
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------

// Filter Plot
filtplot = plot(filt, title="Filter", color=fcolor, linewidth=3)

// Band Plots
hbandplot = plot(hband, title="Filtered True Range High Band", color=fcolor)
lbandplot = plot(lband, title="Filtered True Range Low Band", color=fcolor)

// Channel Fill
fill(hbandplot, lbandplot, title="Channel Fill", color=color.new(fcolor, 80))

// Bar Color
barcolor(barcolor)

// Trading Logic
longCondition = ta.crossover(close, hband) and timeCondition
closeAllCondition = ta.crossunder(close, hband) and timeCondition

if longCondition
    strategy.entry("long", strategy.long)

if closeAllCondition
    strategy.close("long")
** [[https://www.youtube.com/watch?v=x0Buw7GRedo][Scalping Was Hard, Until I Found This Strategy (INSANE VALUE!)]]
** [[https://youtu.be/WqTzkt73Vx0?si=rLm8ltCUowJ0EO7l][Do this every morning to make easy money ($4000/Day)]]
* actions
** learn back testing with trading view
** learn about back testing using trading view
* project automated tradeing
** create dydx new account
*** DONE create a new metamask wallet 
CLOSED: [2025-01-28 Tue 18:05]
*** DONE create a new dydx account
CLOSED: [2025-01-28 Tue 18:05]
** create a module to set orders
*** DONE create buy order market
CLOSED: [2025-01-28 Tue 18:05]
*** create sell order market
*** set take profit market
*** set stop loss market
** find a way to collect data from multiple sources
* information
** who do i get binance btc/usd liquidation heat map
* trading platforms
** dydx
** bybit
** Apexomni
* libaries to use to scrape
** https://github.com/rebrowser/rebrowser-patches?tab=readme-ov-file
** [#A] [[https://github.com/Kaliiiiiiiiii-Vinyzu/patchright][patchright]]
* [[https://www.youtube.com/watch?v=_2_4B9BePdM][entiry]]
* platforms
MEXC	Spot & Perpetual	Typically exist and can vary.	Known for its vast selection of altcoins and user-friendly interface. The exchange has implemented various security measures, including proof-of-reserves.
Bybit	Spot & Perpetual	Daily and monthly withdrawal limits for unverified accounts.	A popular platform with a strong focus on derivatives trading. Bybit has a good security track record and offers features like a bug bounty program.
Phemex	Spot & Perpetual	Withdrawal limits are in place for non-KYC users.	Phemex emphasizes its high-performance trading engine and user-friendly design. It employs a multi-signature cold wallet system for asset security.
dYdX	Perpetual (Primary)	No withdrawal limits as users control their own funds.	As a decentralized exchange, dYdX offers a high degree of security and transparency. The platform's code is open-source and has been audited.
PrimeXBT	Spot & Derivatives	KYC requirements for full functionality may apply.	Offers a wide range of markets beyond crypto. Security features include cold storage and two-factor authentication.
* coing to trade
** eth
** bitcoin
** xrp
** Doge
** cardano
** sui
** solana
- not good for turtle trading
** Avax
- not suitable for turtle trading
** pepe
- not suitable for turtle trading
** shiba
- not suitable for turtle trading
** bittensor
** Atom
** ARB
** pyth-usd
** BNB
- not good for turtle trading
pyusd
* TODO https://www.youtube.com/watch?v=Wtg8GOslFHQ
* TODO https://www.youtube.com/watch?v=NOO6pTBfO7Y
* https://www.youtube.com/watch?v=oW6MHjzxHpU
* [[https://youtu.be/elz6mWy1Jns?si=qhZCykCqilZM8fEH][lessons learned from 9 years of crypto market]]

This video provides a comprehensive guide to crypto investing, emphasizing the following key lessons:

Understanding the Game: The video stresses the importance of knowing whether you're a short-term trader, a medium-term investor, or a long-term investor, as this will dictate your strategy. Long-term investing is presented as the most straightforward path to success [08:13].

Favorable Conditions: Invest when the market fundamentals are in your favor. The video likens this to selling ice cream in summer versus winter, highlighting that there are "seasons" in crypto that are more conducive to making money [09:21].

Risk Management: Investing is not about predicting the future but about managing risk [12:27]. Unforeseen events can always occur, making risk management crucial for survival.

Accepting Imperfection: You will make mistakes and lose money on some investments. It's an inevitable part of the process [14:32].

Volatility: The crypto market is highly volatile. Be prepared for significant price swings [15:07].

Token Failure: A vast majority of crypto tokens will not survive in the long run. It's essential to differentiate between short-term narrative plays and long-term investments in projects with strong fundamentals [15:51].

Contrarian Thinking: The best opportunities often arise when market sentiment is at its most extreme, whether negative or positive. Be prepared to go against the crowd [17:48].

Position Sizing: Never allocate too much of your portfolio to a single asset. This is a critical rule for managing risk [18:55].

Beware of Bias: Everyone has a bias towards the tokens they own. Always do your own research and be skeptical of recommendations [21:00].

Influencer Awareness: Be cautious of influencers who may be engaging in "pump and dump" schemes [22:22].

Key Metrics: Understand the difference between market cap and fully diluted valuation (FDV) to accurately assess a project's size and potential for future token issuance [23:25, 24:04].

Long-Term Outlook: While the overall crypto market is expected to grow, most individual tokens will fail. The biggest returns will come from identifying the few projects that will survive and thrive in the long term [25:27].
* when to exit crypto market
** crypto fall signs
*** over leveraged positions
people start to buy dips with debt
*** 
*** 
* projects
** [[id:9C4340C9-EE58-49D1-BBA2-40012C6926E7][bitcoin]]
** [[id:306CCF61-4AE8-43C1-A356-B86F831FB786][etherium]]
** [[id:4ffaebfb-a864-4eac-a21a-6532c949c755][bnb]]
** [[id:ba57195a-3062-4aba-b8c9-5a4be9625def][sol]]
** [[id:de769340-83d8-4e6b-a3d3-5a40c27a99fb][ada]]
** [[id:a46f0c76-6e7b-47ad-8d79-60610d7b92dc][dot]]
* 



ca@r@5ZzJ&TB8TL
